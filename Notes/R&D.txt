| Pandas (Pros)                                 | SQL (Pros)                                   |
|-----------------------------------------------|----------------------------------------------|
| User-friendly syntax                          | Optimal performance for large datasets       |
| Excellent for exploratory data analysis       | Efficient querying and indexing              |
| Seamless integration with Python              | Robust data integrity and consistency        |

| Pandas (Cons)                                | SQL (Cons)                                  |
|-----------------------------------------------|----------------------------------------------|
| Slower performance for large datasets         | Steeper learning curve                      |
| Limited support for complex joins             | Syntax variations across database systems    |


Common Errors and Solutions
Pandas Common Errors
Memory Issues: Handling large datasets in Pandas may lead to memory errors. To address this, consider processing data in chunks or using more memory-efficient data types.

Inefficient Iteration: Iterating over rows in a DataFrame can be slow. Utilize vectorized operations in Pandas to enhance performance.

SQL Common Errors
Poorly Optimized Queries: Unoptimized SQL queries can be a bottleneck. Ensure your queries are well-structured, and consider indexing columns frequently used in search conditions.

Incorrect Joins: Misusing or omitting join conditions can lead to incorrect results. Double-check your join statements and ensure they match your data relationships.

#############################################################################################################################

**In SQL, the GROUP BY clause is used to group rows that have the same values in one or more columns into summary rows, while the HAVING clause is used to filter these grouped rows based on a specified condition. The WHERE clause filters individual rows before grouping, while the HAVING clause filters groups after they are formed.**

GROUP BY Clause:
Purpose: Groups rows based on the values in specified columns.
Syntax: GROUP BY column1, column2, ...
Usage: Used to aggregate data, calculate summary statistics for each group, and perform analysis on grouped data.
Example: SELECT department, AVG(salary) FROM employees GROUP BY department; (calculates the average salary for each department) 

HAVING Clause:
Purpose: Filters the grouped rows based on a condition.
Syntax: HAVING condition
Usage: Used to filter the results of a GROUP BY query, typically based on aggregate functions like SUM, AVG, COUNT, MAX, or MIN.
Example: SELECT department, AVG(salary) FROM employees GROUP BY department HAVING AVG(salary) > 50000; (selects departments with an average salary greater than 50000) 

Key Differences:
Filtering Scope: WHERE filters rows before grouping, while HAVING filters groups after grouping.
Aggregate Functions: HAVING can use aggregate functions in its condition, while WHERE cannot.
Order of Execution: WHERE is executed before GROUP BY, and HAVING is executed after GROUP BY. 

+-------------------------------------------------------------+
| Example:                                                    |
|                                                             |
| SELECT department, COUNT(*) as num_employees                |
| FROM employees                                              |
| WHERE salary > 30000                                        |
| GROUP BY department                                         |
| HAVING COUNT(*) > 5;                                        |
+-------------------------------------------------------------+

In this example: 
WHERE salary > 30000 filters out employees with salaries less than or equal to 30000.
GROUP BY department groups the remaining employees by department.
HAVING COUNT(*) > 5 filters the grouped departments, selecting only those with more than 5 employees.

#############################################################################################################################

etl_project/
â”‚
â”œâ”€â”€ etl/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config.py               # DB and email settings
â”‚   â”œâ”€â”€ extract.py              # Extract CSV data
â”‚   â”œâ”€â”€ transform.py            # Clean and format data
â”‚   â”œâ”€â”€ load.py                 # Insert/Upsert to MySQL
â”‚   â””â”€â”€ alerts.py               # Email alert logic
â”‚
â”œâ”€â”€ logs/
â”‚   â””â”€â”€ etl.log                 # Auto-generated logs
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ new_sales_data.csv      # Source file
â”‚
â”œâ”€â”€ run_etl.py                  # Main driver script
â””â”€â”€ README.md

ðŸ” WHERE Clause
- Purpose: Filters individual rows before any grouping or aggregation.
- Used with: Regular columns (not aggregate functions).
- Example:
SELECT * FROM sales
WHERE region = 'West' AND quantity > 10;
- âœ… Filters raw data before grouping.

ðŸ“¦ GROUP BY Clause
- Purpose: Groups rows that share the same values in specified columns.
- Used with: Aggregate functions like SUM(), AVG(), COUNT(), etc.
- Example:
SELECT region, SUM(sales) FROM sales
GROUP BY region;
- âœ… Organizes data into buckets for aggregation.

ðŸ§® HAVING Clause
- Purpose: Filters groups after aggregation.
- Used with: Aggregate functions.
- Example:
SELECT region, SUM(sales) AS total_sales
FROM sales
GROUP BY region
HAVING SUM(sales) > 50000;
- âœ… Applies conditions to grouped results.

ðŸ§  Execution Order (Behind the Scenes)
- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY
This order explains why HAVING can use aggregate functions but WHERE cannot.

#############################################################################################################################
